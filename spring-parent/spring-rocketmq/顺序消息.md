### 发送消息


##### 函数原型
```
public SendResult syncSendOrderly(String destination, Object payload, String hashKey)
```

##### 使用
```
rocketMQTemplate.syncSendOrderly(orderPaidTopic, i+" oH1", i+"");
rocketMQTemplate.syncSendOrderly(orderPaidTopic, i+" oH2", i+"");
rocketMQTemplate.syncSendOrderly(orderPaidTopic, i+" oH3", i+"");
```

> 对于一组顺序消息，他们的hashKey必须相同


### 消费消息

> 设置 consumeMode 为 ConsumeMode.ORDERLY
> 

```
@Slf4j
@Service
@RocketMQMessageListener(topic = "${spring.rocketmq.orderTopic}", consumeMode = ConsumeMode.ORDERLY, consumerGroup =
        "order-paid-consumer")
public class OrderPaidEventConsumer implements RocketMQListener<MessageExt> {

    @Override
    public void onMessage(MessageExt orderPaidEvent) {
        try {
            log.info("消费次数{} ------- OrderPaidEventConsumer received: {}", orderPaidEvent.getReconsumeTimes(), new
                    String(orderPaidEvent.getBody(), "UTF-8"));
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
//        throw new RuntimeException("xxxxx");
    }
}
```

### 原理


```
public class DefaultMessageListenerOrderly implements MessageListenerOrderly {

    @SuppressWarnings("unchecked")
    public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {
        for (MessageExt messageExt : msgs) {
            log.debug("received msg: {}", messageExt);
            try {
                long now = System.currentTimeMillis();
                rocketMQListener.onMessage(doConvertMessage(messageExt));
                long costTime = System.currentTimeMillis() - now;
                log.info("consume {} cost: {} ms", messageExt.getMsgId(), costTime);
            } catch (Exception e) {
                log.warn("consume message failed. messageExt:{}", messageExt, e);
                context.setSuspendCurrentQueueTimeMillis(suspendCurrentQueueTimeMillis);
                return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;
            }
        }

        return ConsumeOrderlyStatus.SUCCESS;
    }
}
```

1. 消费成功，返回ConsumeOrderlyStatus.SUCCESS
2. 消费失败，ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT，当前queue会被锁住，不能从里面拿任何数据，只会重复推送第一调条数据。

